// Code generated by protoc-gen-gogo.
// source: asym.proto
// DO NOT EDIT!

/*
Package asym is a generated protocol buffer package.

It is generated from these files:
	asym.proto

It has these top-level messages:
	M
	MyType
*/
package asym

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/gogoproto"

import bytes "bytes"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type M struct {
	Arr              []MyType `protobuf:"bytes,1,rep,name=arr,customtype=MyType" json:"arr"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *M) Reset()         { *m = M{} }
func (m *M) String() string { return proto.CompactTextString(m) }
func (*M) ProtoMessage()    {}

type MyType struct {
	XXX_unrecognized []byte `json:"-"`
}

func (m *MyType) Reset()         { *m = MyType{} }
func (m *MyType) String() string { return proto.CompactTextString(m) }
func (*MyType) ProtoMessage()    {}

func init() {
	proto.RegisterType((*M)(nil), "asym.M")
	proto.RegisterType((*MyType)(nil), "asym.MyType")
}
func (this *M) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*M)
	if !ok {
		that2, ok := that.(M)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *M")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *M but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *M but is not nil && this == nil")
	}
	if len(this.Arr) != len(that1.Arr) {
		return fmt.Errorf("Arr this(%v) Not Equal that(%v)", len(this.Arr), len(that1.Arr))
	}
	for i := range this.Arr {
		if !this.Arr[i].Equal(that1.Arr[i]) {
			return fmt.Errorf("Arr this[%v](%v) Not Equal that[%v](%v)", i, this.Arr[i], i, that1.Arr[i])
		}
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return fmt.Errorf("XXX_unrecognized this(%v) Not Equal that(%v)", this.XXX_unrecognized, that1.XXX_unrecognized)
	}
	return nil
}
func (this *M) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*M)
	if !ok {
		that2, ok := that.(M)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if len(this.Arr) != len(that1.Arr) {
		return false
	}
	for i := range this.Arr {
		if !this.Arr[i].Equal(that1.Arr[i]) {
			return false
		}
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *MyType) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*MyType)
	if !ok {
		that2, ok := that.(MyType)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *MyType")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *MyType but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *MyType but is not nil && this == nil")
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return fmt.Errorf("XXX_unrecognized this(%v) Not Equal that(%v)", this.XXX_unrecognized, that1.XXX_unrecognized)
	}
	return nil
}
func (this *MyType) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*MyType)
	if !ok {
		that2, ok := that.(MyType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
